In order to create Finance 2.0, we used the programs python, flask, html, css, SQL, and javascript. We also made use of various APIs in order to get the financial data for our pages.

For the styling, we made use of CSS in order to edit the design of mostly every aspect of the page. Bootstrap was used to edit different classes of css. Some fonts were imported from outside sources such as the font we used for the navbar.

We used SQL to log all of our trades, then running queries to select positions that were active with quantity > 0. We used IEX Cloud to source our quotes from our positions, and presented these usinga table. Because we are calling a bunch of different APIs, it took forever for us to load big portfolios. Because of this, we decided to make a SQL table that has each stock ticker, price, and latest time it updated. This way, we can just update stocks three times a day and have the user sit through the loading process only three times a day, compared to every time they click index. This also allows for overlap: a popular stock like $AAPL would most likely be owned by multiple people, so only one person would have to load it. Then, we allowed the user to manually update in case they really wanted to see where their positiosn stood. For index, we also used loops to sum up total market value by industry and style so that they could be graphed using a Google Chart API.
We also did the same update logic for the earnings calendar, calling an API for all our stocks for the latest earnings, and then we store this in a SQL database to only update if the earnings calendar database was not updated that day.

For the markets page, we called a finnhub API to get the recent news and present those in a table. We used tradingview widgets to get charts of the overall markets.

On the lookup page, we used a form to then run a POST connection. After getting the ticker, we passed in a URL to a tradingview widget to get the chart. We called finnhub to get fundamental data to then add to the page via table. One thing we had to do was check to make sure finnhub supported the stock (Tradingview could show charts for foreign ADRs but finnhub had no financials on those). To do this, we added test case via Jinja by checking if we were passing in a list of none. The structure of the page was formatted with HTML, where we used different divs for each section. For the company profile section of the page, we used a for loop within jinja to pass along the information from the Finnhub API.

On the watchlist page, we used SQL databases to store users and their watchlists. Every user is given a default watchlist and watchlist routes to there. The user can add watchlists, which adds a new watchlist to the SQL database, and add stocks to it, which is a different SQL table joined to watchlists. We used javascript to show and hide buttons to add/delete watchlists. The watchlists were then displayed in a table next to a tradingview chart showing the performance of that stock from a year.

Tradelog uses a table to show a query of all the user's inputted trades. We redirect to an edit.html page if the user clicks edit, which then updates the SQL database about the changes the user makes. If a user makes a trade, cash amount the size of the trade is taken out of the user's balance, which is a SQl database. The user can edit their trades by clicking edit, which updates the SQL database of trades placed and also adjusts the cash accordingly.

